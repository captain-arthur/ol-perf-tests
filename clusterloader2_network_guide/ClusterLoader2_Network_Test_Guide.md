# ClusterLoader2 실전 가이드: 네트워크 성능 테스트의 모든 것

이 문서는 쿠버네티스 대규모 성능 테스트 프레임워크인 **ClusterLoader2**가 네트워크 테스트(TCP, UDP, HTTP)를 수행하기 위해 내부적으로 어떻게 설계되어 있고, 코드가 어떻게 맞물려 돌아가는지 초보자도 이해하기 쉽게 풀어서 설명한 **완전 정복 가이드**입니다.

---

## 1. 기반 지식: 통신사별 무전기 테스트하기

이해를 돕기 위해 비유를 들어보겠습니다. 여러분이 100만 명의 인원이 동시에 사용하는 무전기 서비스(클러스터 네트워크 환경)의 성능을 테스트하는 감독관이라고 가정해 봅시다.

1. **상황:** 100만 명이 동시에 무전기를 쓰면 끊기지 않을지 알아보고 싶습니다.
2. **iperf (테스트 도구):** 이건 진짜로 트래픽을 만들어주는 "테스트용 무전기" 기계입니다. 상대방 기계와 연결해서 *"아!아! 1초에 1기가바이트 어치 소리를 지를게!"* 하고 통신을 쏟아붓고, *"나는 몇 기가 받았어!"*라고 확인하는 **단순하지만 무식하게 강력한 네트워크 부하 발생기**입니다. 네트워크 엔지니어들이 네트워크 통신 대역폭(Bandwidth)을 잴 때 쓰는 벤치마킹 표준 프로그램입니다.
3. **YAML 파일 (작전 계획서):** 감독관인 여러분이 작성하는 문서입니다. *"이번 작전은 TCP 방식으로, 병사 50명이, 60초 동안 무전기를 사용해라."* 라고 적습니다.
4. **ClusterLoader2 (부대 지휘관):** 작전 계획서를 읽고 실제로 병사(컨테이너)들을 훈련소 곳곳(노드)에 배치한 뒤, 호루라기를 불어 **"다 같이 15초 뒤에 쏴라!"** 하고 통제하는 오케스트레이션 프로그램입니다. 지휘관은 무전기를 직접 들고 쏘지 않습니다. 통제만 할 뿐입니다.

---

## 2. 코드 구조: main.go부터 트래픽이 쏟아지기까지

ClusterLoader2는 쿠버네티스의 철학처럼 "선언적"으로 동작합니다. 동작 과정은 크게 4단계로 나뉘며, 코드는 그 흐름을 따라갑니다.

### ① 진입점 (Entrypoint): `cmd/clusterloader.go`
* **무엇을 하는가?**: ClusterLoader2 바이너리가 처음 실행되는 곳(`main` 함수)입니다.
* **원리**: 
  1. CLI 명령어(예: `--testconfig=.../suite.yaml`)로 넘겨진 **작전 계획서(YAML) 파일**의 경로를 읽습니다.
  2. YAML 내용을 컴퓨터가 이해할 수 있는 메모리 객체로 매핑합니다. 
  3. `framework.Run()`을 호출하여 본격적으로 YAML에 적힌 각 단계(Step)들을 하나씩 순서대로 실행시킵니다. 

### ② 테스트 측정소 등록: `pkg/measurement/common/network/network_performance_measurement.go`
이 파일이 테스트의 **"알파이자 오메가(핵심 지휘소)"**입니다. 이 Go 파일이 여러분의 클러스터에서 실질적인 통제를 책임집니다.

* **`init()` 함수**:
  프로그램이 켜지자마자 실행되어, "나는 `NetworkPerformanceMetrics`라는 작전 코드를 알아들을 수 있는 관제소다"라고 프레임워크 본부에 자신을 등록합니다. (이래서 YAML에 `Identifier: NetworkPerformanceMetrics`라고 적으면 이 파일의 코드들이 호출되는 것입니다.)
  
* **`Execute(config)` 함수**:
  YAML 파일에서 `action`이 `start`로 되어 있는지, `gather(결과 수집)`로 되어 있는지 확인하고 각각 `start()`와 `gather()` 함수로 분기합니다.

### ③ Action: `start` (파드 배포 및 통신 동기화)
YAML에 `action: start`가 호출되면 지휘관 프로그램(`start()` 함수)은 아래 순서로 행동을 개시합니다.
1. `prepareCluster()`: `netperf`라는 테스트 전용 네임스페이스를 만들고, 거기에 CRD(네트워크 테스트 기록용 Custom Resource)를 배포합니다. 
2. `createAndWaitForWorkerPods()`: **진짜 트래픽을 쏠 컨테이너(병사들)를 투입하는 단계입니다.** 
   여기서 `manifests/worker-deployment.yaml` 파일(Deployment 매니페스트)을 읽습니다. 이 YAML에는 `gcr.io/k8s-testimages/netperfbenchmark:0.3` 라는 **iperf가 이미 설치된 도커 이미지**를 다운받아 띄우라는 명령이 적혀있습니다.
3. 잠시 후, `getNumberOfClients + getNumberOfServers`의 개수만큼 Pod가 클러스터의 워커 노드들에 퍼져서 실행(Running)될 때까지 기다립니다.
4. `execNToMTest()` & `createCustomResourcePerUniquePodPair()`: 
   Pod들이 전부 배치되면, 서로 통신을 주고받을 클라이언트와 서버를 **짝(Pair)** 지어 줍니다.
   **[가장 중요한 원리]**: 50개의 클라이언트가 제각각 트래픽을 쏘게 놔두면 정확한 최고 부하 테스트가 안 됩니다. 그래서 지휘관(Go 코드)이 `현재 시간 + 15초(initialDelayForTestExecution)`로 계산된 미래의 특정 시간 타임스탬프를 계산하여 찍습니다. 그리고 "야, 너희들 내 시계로 정확히 서버 시간 15시 00분 15초가 되는 순간 동시에 쏴!"라는 지시를 쿠버네티스 CRD 객체를 통해 각 파드에게 하달합니다.

### ④ Action: `gather` (결과 취합)
테스트 지정 시간(예: `duration: 60s`)이 지난 시점에, 작전 계획서의 두 번째 단계인 `action: gather`가 호출됩니다. (`gather()` 함수 실행)
* Pod(iperf 기반 병사)들은 테스트를 끝마치면 자신이 쏜 대역폭/응답속도를 아까 하달받았던 CRD(`networktestrequests.clusterloader.io`)의 `status` 필드에 기록합니다.
* 지휘관(Go 코드)은 파드들이 결과를 제대로 적었는지 `waitForMetricsFromPods()`를 통해 기다리고, 누락된 파드는 없는지 확인합니다 (여기서 응답을 제때 안 적어두면 이전 문제처럼 `Failed to receive response` 에러 발생).
* 전부 도착하면 서버 결과를 합산해 초당 처리량(Bandwidth) 등 50%, 90% 백분위수로 이쁘게 JSON 통계를 냅니다.

---

## 3. 프로토콜별 차이점 요약 (TCP vs UDP vs HTTP)

YAML 파일(`config.yaml`)에 `protocol`을 무엇으로 주느냐에 따라 병사(`netperfbenchmark` 컨테이너 내의 스크립트)들이 행동하는 양식이 달라집니다. ClusterLoader2는 아래 방식을 지원합니다.

### 1) TCP (Transmission Control Protocol)
* **어떻게 동작하는가?**: `iperf -c` 명령어를 백그라운드에서 실행합니다. 상대방과 세션(3-Way Handshake)을 단단하게 맺은 후 데이터를 쏟아붓습니다. 
* **설명**: 전화를 거는 것과 같습니다. 서로 목소리가 들리는지 핑퐁을 한 번 치고 나서야 썰을 풀듯, "신뢰성"이 높은 통신입니다.
* **무엇을 검증하는가?**: `Bandwidth`(대역폭, 단위 `Mbit/sec`). 연결이 얼마나 안정적으로 넓은 데이터 차선폭을 유지하는지 봅니다.

### 2) UDP (User Datagram Protocol)
* **어떻게 동작하는가?**: `iperf -u -c`로 동작합니다. 세션을 맺지 않고 일방적으로 통신문을 쏴버서 던집니다.
* **설명**: 확성기로 고함을 지르는 것과 같습니다.相手이 듣던 말던 내지릅니다. 영상 스트리밍, 게임 등에 주로 쓰입니다.
* **무엇을 검증하는가?**: 대역폭보다 **패킷 손실률(Lost Packets)**, **지터(Jitter, 네트워크 지연의 불규칙성)**, 초당 오가는 패킷 수 등을 측정합니다. 

### 3) HTTP (HyperText Transfer Protocol)
* **어떻게 동작하는가?**: iperf를 쓰지 않고, 내부적으로 웹 요청(Get/Post)을 날리고 응답 헤더를 받는 별도의 HTTP 벤치마킹 도구를 씁니다.  
* **설명**: "저기요, 이 책(웹페이지) 내용 좀 주실래요?" 하고 서점에 요청해서 책을 받는 과정입니다. TCP 위에서 동작하는 추상화된 웹 통신 부하를 만듭니다.
* **무엇을 검증하는가?**: **Response Time (응답 지연 시간).** HTTP 요청을 보냈을 때 얼마나 빨리 결과물(HTTP 200 OK 등)이 되돌아오는지를 측정합니다.

---

## 4. 커스터마이징 전략 : 우리는 YAML만 고쳐도 됩니다.

이 모든 톱니바퀴 흐름을 보셨다면 아시겠지만, **새로운 통신 프로토콜을 백지부터 만들거나, "응답 지연 시간 평균값 대신 세제곱값을 구해줘!" 같은 특이한 로직이 필요한 게 아니라면, Go 코드를 열어서 빌드할 필요가 절대 없습니다.**

* **트래픽을 쏘는 방식을 바꾸고 싶을 때:** `worker-deployment.yaml`에서 이미지 버전을 바꾸거나, 리소스(CPU 제한 등)를 올리거나 깎습니다. 또는 파드가 뛸 노드를 강제하기 위해 `nodeSelector`를 추가하세요.
* **부하량을 조정하고 싶을 때:** `suite.yaml`, `config.yaml` 에서 `numberOfClients`나 `duration` 값을 튜닝하시면 끝납니다!

이 가이드 문서가 ClusterLoader2의 보이지 않는 막막함을 해소하는 데 도움이 되기를 바랍니다.
